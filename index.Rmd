---
title       : Stepwise n-gram building
author      : Michal Burdukiewicz, Piotr Sobczyk
framework   : io2012 
highlighter : highlight.js
hitheme     : zenburn 
widgets     : mathjax       # {mathjax, quiz, bootstrap}
mode        : selfcontained
knit        : slidify::knit2slides
---

### Outline

`r opts_chunk$set(cache=TRUE)`

1. n-gram definition.
2. Iterative n-gram building.
3. Results.
4. Drawbacks and limitations.


--- 



### n-grams (k-mers)

n-grams (k-tuples) are vectors of n characters derived from input sequence(s). They may form continuous sub-sequences or be discontinuous.  


Important n-gram parameter is its position. Instead of just counting n-grams, one may want to count how many n-grams occur at a given position in multiple (e.g. related) sequences.


--- 



### 1-grams


```{r, echo=FALSE,results='asis'}
# the echo=5 tells knitr that I want all lines to run but only show #5
library(reshape2)
library(ggplot2)
library(grid)
library(biogram)
library(xtable)

set.seed(1)
sample_seq <- matrix(sample(c("A", "C", "G", "T"), 18, replace = TRUE), nrow = 3)
colnames(sample_seq) <- paste0("P", 1L:ncol(sample_seq))
rownames(sample_seq) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(data.frame(sample_seq), caption = "Sample sequences.  S - sequence, P - position.", digits = 0), type = "html")
```
  
&nbsp;
  
```{r, echo=FALSE,results='asis'}
unis <- count_ngrams(sample_seq, 1, c("A", "C", "G", "T"))
unis <- data.frame(as.matrix(unis))
colnames(unis) <- c("A", "C", "G", "T")
rownames(unis) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(unis, caption = "1-gram counts.", digits = 0), include.rownames = TRUE, type = "html")
```

--- 

### 2-grams


```{r, echo=FALSE,results='asis'}
# the echo=5 tells knitr that I want all lines to run but only show #5
library(reshape2)
library(ggplot2)
library(biogram)
library(xtable)

set.seed(1)
sample_seq <- matrix(sample(c("A", "C", "G", "T"), 18, replace = TRUE), nrow = 3)
colnames(sample_seq) <- paste0("P", 1L:ncol(sample_seq))
rownames(sample_seq) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(data.frame(sample_seq), caption = "Sample sequences.  S - sequence, P - position.", digits = 0), type = "html")
```
  
&nbsp;
  
```{r, echo=FALSE,results='asis'}
unis <- count_ngrams(sample_seq, 2, c("A", "C", "G", "T"))
unis <- data.frame(as.matrix(unis))

colnames(unis) <- sapply(colnames(unis), function(i) 
                         paste0(substr(i, 0, 1), substr(i, 3, 3)))

#colnames(unis) <- c("A", "C", "G", "T")
rownames(unis) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(unis, caption = "2-gram counts.", digits = 0), include.rownames = TRUE, type = "html")
```

--- 


### 2-grams with position information


```{r, echo=FALSE,results='asis'}
# the echo=5 tells knitr that I want all lines to run but only show #5
library(reshape2)
library(ggplot2)
library(biogram)
library(xtable)

set.seed(1)
#sample_seq <- matrix(sample(c("A", "C", "G", "T"), 18, replace = TRUE), nrow = 3)
colnames(sample_seq) <- paste0("P", 1L:ncol(sample_seq))
rownames(sample_seq) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(data.frame(sample_seq), caption = "Sample sequences.  S - sequence, P - position.", digits = 0), type = "html")
```
  
&nbsp;
  
```{r, echo=FALSE,results='asis'}
unis <- count_ngrams(sample_seq, 2, c("A", "C", "G", "T"), pos = TRUE)
unis <- data.frame(as.matrix(unis))

#colnames(unis) <- c("A", "C", "G", "T")
rownames(unis) <- paste0("S", 1L:nrow(sample_seq))
print(xtable(unis[, 1L:8], caption = "Part of 2-gram counts.", digits = 0), include.rownames = TRUE, type = "html")
```


--- 

### Curse of dimensionality

$$n_{\text{max}} = p \times m^n$$

$n_{\text{max}}$: total number of n-grams.

$p$: number of possible positions.

$m$: number of letters in the alphabet.

--- 

### Curse of dimensionality

$$n_{\text{max}} = p \times m^n$$

```{r, echo=FALSE, fig.width=13.5}
library(grid)
n <- 1:6
n_max <- 4^n

dat <- melt(sapply(c(1, 2:5*5), function(i) i * n_max))
dat[["Var2"]] <- factor(dat[["Var2"]])
levels(dat[["Var2"]]) <- c(1, 2:5*5)
colnames(dat) <- c("n", "p", "n_max")
ggplot(dat, aes(x = n, y = n_max, fill = p, col = p)) + 
  geom_line(linetype="dotted", size=1.5) + 
  geom_point(size=7, shape=21) +
  scale_x_continuous(breaks = 0L:6) +
  scale_y_continuous(expression(n["max"])) + 
  theme(plot.background=element_rect(fill = "transparent",
                                                   colour = "transparent"),
                      plot.margin = unit(c(1,1,1,1), "cm"),
                      axis.text.x = element_text(size=17), 
                      axis.text.y = element_text(size=17),
                      axis.title.x = element_text(size=20, vjust = -1), 
                      axis.title.y = element_text(size=20, vjust = 1),
                      strip.text = element_text(size=20),
                      legend.text = element_text(size=17), 
                      legend.title = element_text(size=20),
                      plot.title = element_text(size=28),
                      panel.background = element_rect(fill = "transparent",colour = "black"),
                      legend.background = element_rect(fill="NA"))
```

--- 

### Case study

We used n-grams to predict cleavage site in signal peptides.

Experiment conditions:  
- 3897 cleavage sites (nonamers from -4 to +4 from cleavage site);  
- 4794 non-cleavage sites (2nd-9th amino acids in proteins with signal peptide and 7th-15th amino acids in mature proteins);  
- amino acids degenerated using scheme from signal.hsmm;
- 1- and 4-grams (no distance between elements, position information).

--- 

### Case study

<table border=1>
<tr> <th> n </th> <th> model </th> <th> AUC - naive approach </th>  </tr>
  <tr> <td align="right">   1 </td> <td> RF </td> <td align="right"> 0.85 </td> </tr>
  <tr> <td align="right">   4 </td> <td> RF </td> <td align="right"> 0.67 </td> </tr>
  <tr> <td align="right">   1 </td> <td> SVMlin </td> <td align="right"> 0.82 </td> </tr>
  <tr> <td align="right">   4 </td> <td> SVMlin </td> <td align="right"> 0.68 </td> </tr>
  <tr> <td align="right">   1 </td> <td> SVMrbf </td> <td align="right"> 0.84 </td> </tr>
  <tr> <td align="right">   5 </td> <td> SVMrbf </td> <td align="right"> 0.62 </td> </tr>
   </table>



---

### Iterative n-gram building

Reason: there are too many possible n-grams. For bigger values of $n$ feature filtering takes too long.


---

### Exact n-gram building algorithm 

1. Extract 1-grams from sequences and filter them.
2. Split n-grams into 1-grams.
3. Join together 1-grams with n-grams in all possible combinations.
4. Filter ($n+1$)-grams (p-value threshold: 0.05).
5. Repeat steps 2-4 till the given value of $n$ or there are no significant n-grams.

---

### Example: exact n-gram building algorithm 

  
```{r, echo=FALSE,message=FALSE,results='asis'}
library(biogram)
library(xtable)
ngrams <- as.vector(seq2ngrams(sample_seq[1, 1L:4], 2, c("A", "C", "G", "T")))
ngrams <- sapply(1L:length(ngrams), function(i) paste0(i, "_", ngrams[i]))
dat <- rbind(ngrams, decode_ngrams(ngrams))
rownames(dat) <- c("biogram notation", "human-readable")
print(xtable(dat, caption = "Filtered 2-grams."), type = "html", include.colnames = FALSE)
```

&nbsp;


```{r, echo=FALSE,message=FALSE,results='asis'}
dat2 <- rbind(add_1grams(ngrams), decode_ngrams(add_1grams(ngrams)))
rownames(dat2) <- c("biogram notation", "human-readable")
print(xtable(dat2, caption = "Possible 3-grams."), type = "html", include.colnames = FALSE)
```

---

### n-gram building algorithm with Hamming distance

1. Extract 1-grams from sequences and filter them.
2. Split n-grams into 1-grams.
3. Join together 1-grams with n-grams in all possible combinations.
4. Create summary feature for each ($n+1$)-gram. A summary feature is a logical alternative of counts for all positioned n-gram which are in given Hamming distance from a ($n+1$)-gram.
5. Filter summary features (p-value threshold: 0.05).
6. Repeat steps 2-5 till the given value of $n$ or there are no significant n-grams.


---

### Example: exact n-gram building algorithm 

  
```{r, echo=FALSE,message=FALSE,results='asis'}
library(biogram)
library(xtable)
ngrams <- as.vector(seq2ngrams(sample_seq[1, 1L:4], 2, c("A", "C", "G", "T")))
ngrams <- sapply(1L:length(ngrams), function(i) paste0(i, "_", ngrams[i]))
dat <- rbind(ngrams, decode_ngrams(ngrams))
rownames(dat) <- c("biogram notation", "human-readable")
print(xtable(dat, caption = "Filtered 2-grams."), type = "html", include.colnames = FALSE)
```

&nbsp;


```{r, echo=FALSE,message=FALSE,results='asis'}
dat2 <- rbind(add_1grams(ngrams), decode_ngrams(add_1grams(ngrams)))
rownames(dat2) <- c("biogram notation", "human-readable")
print(xtable(dat2, caption = "Possible 3-grams."), type = "html", include.colnames = FALSE)
```


&nbsp;


```{r, echo=FALSE,message=FALSE,results='asis'}
dat2 <- rbind(gap_ngrams(add_1grams(ngrams)[1]), 
              decode_ngrams(gap_ngrams(add_1grams(ngrams)[1])))
rownames(dat2) <- c("biogram notation", "human-readable")
print(xtable(dat2, caption = paste0("n-grams in the Hamming distance 1 from n-gram ",
                                    add_1grams(ngrams)[1], " (", decode_ngrams(add_1grams(ngrams)[1]), ").")), 
      type = "html", include.colnames = FALSE)
```

---

### Results

<table border=1>
<tr> <th> n </th> <th> model </th> <th> AUC - naive approach </th> <th> AUC - constructed </th>  </tr>
  <tr> <td align="right">   1 </td> <td> RF </td> <td align="right"> 0.85 </td> <td align="right"> 0.85 </td> </tr>
  <tr> <td align="right">   5 </td> <td> RF </td> <td align="right"> 0.67 </td> <td align="right"> 0.67 </td> </tr>
  <tr> <td align="right">   1 </td> <td> SVMlin </td> <td align="right"> 0.82 </td> <td align="right"> 0.82 </td> </tr>
  <tr> <td align="right">   5 </td> <td> SVMlin </td> <td align="right"> 0.68 </td> <td align="right"> 0.69 </td> </tr>
  <tr> <td align="right">   1 </td> <td> SVMrbf </td> <td align="right"> 0.84 </td> <td align="right"> 0.84 </td> </tr>
  <tr> <td align="right">   5 </td> <td> SVMrbf </td> <td align="right"> 0.62 </td> <td align="right"> 0.62 </td> </tr>
   </table>

---


### Results

Average AUC is for constructed 3- and 4-gram is nearly the same as for non-constructed 3- and 4-grams (filtered all possible 3- and 4-grams without any distance between elements).

---

### Drawbacks and limitations

Drawbacks:
* iteratively built n-grams do not provide more information about the differences between sequences;
* constructing n-grams is slow.


Limitations
* bottleneck: counting constructed n-grams in sequences;
* impossible to insert unigram between elements of n-gram.
* heavy emphasis on position severily restricts the algorithm.

